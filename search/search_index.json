{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tracetest Trace-based testing. End-to-end tests powered by your OpenTelemetry Traces. Tracetest allows you to quickly build integration and e2e tests, powered by your OpenTelementry traces. Point the system to your Jaeger or Tempo trace datastore. Define a triggering transaction, such as a GET against an API endpoint. The system runs this transaction, returning both the response data and a full trace. Define tests & assertions against this data, ensuring both your response and the underlying processes worked correctly, quickly, and without errors. Save your test. Run the tests either manually or via your CI build jobs. Blog & Video Posts Check out the following blog posts & videos with Tracetest-related content: Frontend Overhaul of the OpenTelemetry Demo (Go to Next.js) - Oct 5, 2022 Enabling Tracetest to Work Directly with OpenSearch - Oct 3, 2022 Is it Observable? with Henrik Rexed - Sep 22, 2022 How Testability Drives Observability - Open Source Summit Dublin - Sep 14, 2022 Tracetest v0.7 Release Notes - Aug 23, 2022 Tracetest Roadmap Planning - In Person, In Cartagena! - Aug 23, 2022 Common Cypress Testing Pitfalls & How to Avoid Them - Aug 18, 2022 Recorded livestream: Tracetest v0.6 Release - gRPC, Postman and More - July 27, 2022 Tracetest 0.6 Release - gRPC, Postman and More - July 27, 2022 Creating a Custom Language Code Editor Using React - July 22, 2022 Integration Tests: Pros and Cons of Doubles vs. Trace-Based Testing - July 13, 2022 Detect & Fix Performance Issues Using Tracetest - July 6, 2022 Integrating Tracetest with GitHub Actions in a CI pipeline - June 24, 2022 Recorded livestream: Introduction to Tracetest - E2E Tests Powered by OpenTelemetry - June 23, 2022 Tracetest \u2014 Assertions, Versioning & CI/CD - Release 0.5 - June 8, 2022 Tracing the History of Distributed Tracing & OpenTelemetry - May 26, 2022 Tracetest is released. What\u2019s next? - May 6, 2022 Introducing Tracetest - Trace-based Testing with OpenTelemetry - April 26, 2022","title":"Welcome"},{"location":"#tracetest","text":"Trace-based testing. End-to-end tests powered by your OpenTelemetry Traces. Tracetest allows you to quickly build integration and e2e tests, powered by your OpenTelementry traces. Point the system to your Jaeger or Tempo trace datastore. Define a triggering transaction, such as a GET against an API endpoint. The system runs this transaction, returning both the response data and a full trace. Define tests & assertions against this data, ensuring both your response and the underlying processes worked correctly, quickly, and without errors. Save your test. Run the tests either manually or via your CI build jobs.","title":"Tracetest"},{"location":"#blog-video-posts","text":"Check out the following blog posts & videos with Tracetest-related content: Frontend Overhaul of the OpenTelemetry Demo (Go to Next.js) - Oct 5, 2022 Enabling Tracetest to Work Directly with OpenSearch - Oct 3, 2022 Is it Observable? with Henrik Rexed - Sep 22, 2022 How Testability Drives Observability - Open Source Summit Dublin - Sep 14, 2022 Tracetest v0.7 Release Notes - Aug 23, 2022 Tracetest Roadmap Planning - In Person, In Cartagena! - Aug 23, 2022 Common Cypress Testing Pitfalls & How to Avoid Them - Aug 18, 2022 Recorded livestream: Tracetest v0.6 Release - gRPC, Postman and More - July 27, 2022 Tracetest 0.6 Release - gRPC, Postman and More - July 27, 2022 Creating a Custom Language Code Editor Using React - July 22, 2022 Integration Tests: Pros and Cons of Doubles vs. Trace-Based Testing - July 13, 2022 Detect & Fix Performance Issues Using Tracetest - July 6, 2022 Integrating Tracetest with GitHub Actions in a CI pipeline - June 24, 2022 Recorded livestream: Introduction to Tracetest - E2E Tests Powered by OpenTelemetry - June 23, 2022 Tracetest \u2014 Assertions, Versioning & CI/CD - Release 0.5 - June 8, 2022 Tracing the History of Distributed Tracing & OpenTelemetry - May 26, 2022 Tracetest is released. What\u2019s next? - May 6, 2022 Introducing Tracetest - Trace-based Testing with OpenTelemetry - April 26, 2022","title":"Blog &amp; Video Posts"},{"location":"accessing-dashboard/","text":"Accessing the Dashboard Please first follow the install steps to install Tracetest. Once installed, you can get started by launching the Tracetest Dashboard by following these instructions: Run: kubectl port-forward svc/tracetest 11633 Then launch a browser to http://localhost:11633/ . To learn how to create your first test, see create a test .","title":"Accessing Tracetest Dashboard"},{"location":"accessing-dashboard/#accessing-the-dashboard","text":"Please first follow the install steps to install Tracetest. Once installed, you can get started by launching the Tracetest Dashboard by following these instructions: Run: kubectl port-forward svc/tracetest 11633 Then launch a browser to http://localhost:11633/ . To learn how to create your first test, see create a test .","title":"Accessing the Dashboard"},{"location":"adding-assertions/","text":"Adding Test Specifications Test Specifications may be added to a trace to set a value for a step in the trace to determine success or failure. If test specs have already been added to a test, they will be on the Test screen: After you have created a test and your test run is complete, click the Add Test Spec button at the bottom right of the Test screen. The Add Test Spec dialog opens. The span that the new test spec will apply to is hightlighted in the graph view on the left: To add an assertion to a span, click the first drop down to see the list of attributes that apply to the selected span: Then select the operator for your assertion: And add the value for comparison: Finally, you can give your test spec an optional name and click Save Test Spec :","title":"Adding Test Specifications"},{"location":"adding-assertions/#adding-test-specifications","text":"Test Specifications may be added to a trace to set a value for a step in the trace to determine success or failure. If test specs have already been added to a test, they will be on the Test screen: After you have created a test and your test run is complete, click the Add Test Spec button at the bottom right of the Test screen. The Add Test Spec dialog opens. The span that the new test spec will apply to is hightlighted in the graph view on the left: To add an assertion to a span, click the first drop down to see the list of attributes that apply to the selected span: Then select the operator for your assertion: And add the value for comparison: Finally, you can give your test spec an optional name and click Save Test Spec :","title":"Adding Test Specifications"},{"location":"advanced-selectors/","text":"Advanced Selectors If you find yourself in a position where you cannot select complex spans, you can use our advanced selectors to help with that task. Advanced selectors enable selecting spans that are impossible to select using just basic selectors. In order to present each selector feature as easily as possible, we will use a theoretical scenario of an e-commerce application. The system that we will inspect has this flow: flowchart LR start((start)) subgraph purchase cart-api purchase-api end subgraph auth auth-api auth-storage[(db)] end subgraph product product-api product-storage[(db)] end subgraph notification notification-api kafka{{kafka}} external-notification-service{{external service}} end start -->|1. Close order| cart-api cart-api-->|5. send buy action| purchase-api purchase-api --> |7. Send notification to user|notification-api purchase-api -->|6. can product be bought by user?| auth-api auth-api --> auth-storage cart-api -->|2. is product available?| product-api product-api -->|4. can user view product?| auth-api product-api -->|3. retrieve product| product-storage notification-api -->|8| kafka kafka -->|9| external-notification-service And it generates the following trace: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K Features Empty Selector By providing an empty selector, all spans from the trace are selected. Note that an empty selector is an empty string. Providing span or span[] as a selector will result as a syntax error. Filter by Attributes The most basic way of filtering the spans to apply an assertion to is to use the span's attributes. A good starting example would be filtering all spans of type http : span [ tracetest . span . type = \"http\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class D selectedSpan class F selectedSpan class G selectedSpan class I selectedSpan AND Condition If you need to narrow down your results, you can provide multiple properties in the selector by separating them using a space. The following will select all http spans AND spans that were created by the service cart-api : span [ tracetest . span . type = \"http\" service . name = \"cart-api\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class F selectedSpan OR Condition Sometimes we want to have a broader result by selecting spans that match different selectors. Let's say we have to get all spans from our services, but not from any other external service. span [ service . name = \"api-product\" ], span [ service . name = \"api-auth\" ], span [ service . name = \"api-notification\" ], span [ service . name = \"api-cart\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class C selectedSpan class D selectedSpan class E selectedSpan class F selectedSpan class G selectedSpan class H selectedSpan class I selectedSpan class J selectedSpan Each span selector will be executed individually and the results will be merged together, creating a list of all spans that match any of the provided span selectors. Contains Operator Although it is possible to filter several span selectors at once to get a broader result, it might become verbose very quickly. The previous example can be written in another way to reduce its complexity: span [ service . name contains \"api\" ] This would select the same spans as the previous example: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class C selectedSpan class D selectedSpan class E selectedSpan class F selectedSpan class G selectedSpan class H selectedSpan class I selectedSpan class J selectedSpan Pseudo-classes Support Sometimes filtering by attributes is not enough because we might have two or three identical spans in the tree but we only want to assert one of them. For example, imagine a system that has a retry policy for all the HTTP requests it sends. How would we allow a user to validate if the third execution was successful without asserting the other two spans? This is where pseudo-classes enter the scene. Pseudo-classes are ways of filtering spans by data that is not present in the span itself. For example, the order which the span appears. Note : Today we support only first , last , and nth_child . If you think we should implement others, please open an issue and explain why it is important and how it should behave. For the examples of the three pseudo-classes, let's consider that we want to select a specific http span based on when it happens. span [ tracetest . span . type = \"http\" ] This will select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class D selectedSpan class F selectedSpan class G selectedSpan class I selectedSpan :first This would return the first appearing span from the list: span [ tracetest . span . type = \"http\" ] : first flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B candidateSpan class D candidateSpan class F candidateSpan class G candidateSpan class I candidateSpan :last This would return the last appearing span from the list: span [ tracetest . span . type = \"http\" ] : last flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A candidateSpan class B candidateSpan class D candidateSpan class F candidateSpan class G candidateSpan class I selectedSpan :nth_child This enables you to fetch any item from the list based on its index. n starts at 1 (first element) and ends at length (last element). Any invalid n value will return in an empty list of spans being returned: span [ tracetest . span . type = \"http\" ] : nth_child ( 3 ) flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A candidateSpan class B candidateSpan class D selectedSpan class F candidateSpan class G candidateSpan class I candidateSpan Parent-child Relation Filtering Even with all those capabilities, we might have problems with ambiguous selectors returning several spans when just a few were intended. In our example, auth-api is called twice from different parts of the trace. At first by product-api and later by cart-api . What if I want to test if a product only available in US can be bought in UK? The product can be seen by the user, but it cannot be bought if the user is outside the US. Certainly, I cannot apply the same assertions on all auth-api spans, otherwise the test will not pass. When you filter by the parent-child relationship, spans are matched recursively in all levels below the parent. This doesn't match only direct children of the parent, but all other spans in the sub-tree. For example: span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] Will return: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class D selectedSpan class G selectedSpan This is a problem, because if we apply the same assertion to both spans, one of them will fail. We could try to use nth_child but that could break if a http request failed and the retry policy kicked in. Thus, the only way of filtering in this scenario is based on the context when it was generated. For example: using its parent span to do so. We could use the purchase products parent to ensure just http class to the auth-api triggered by the purchase-api would be selected: span [ service . name = \"cart-api\" , name = \"purchase products\" ] span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] This would find the parent span and only select the spans that are descedents of that parent and match the provided filter: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef parentSpan fill:#3792cb, color:#ffffff class F parentSpan class G selectedSpan","title":"Specifying Selectors"},{"location":"advanced-selectors/#advanced-selectors","text":"If you find yourself in a position where you cannot select complex spans, you can use our advanced selectors to help with that task. Advanced selectors enable selecting spans that are impossible to select using just basic selectors. In order to present each selector feature as easily as possible, we will use a theoretical scenario of an e-commerce application. The system that we will inspect has this flow: flowchart LR start((start)) subgraph purchase cart-api purchase-api end subgraph auth auth-api auth-storage[(db)] end subgraph product product-api product-storage[(db)] end subgraph notification notification-api kafka{{kafka}} external-notification-service{{external service}} end start -->|1. Close order| cart-api cart-api-->|5. send buy action| purchase-api purchase-api --> |7. Send notification to user|notification-api purchase-api -->|6. can product be bought by user?| auth-api auth-api --> auth-storage cart-api -->|2. is product available?| product-api product-api -->|4. can user view product?| auth-api product-api -->|3. retrieve product| product-storage notification-api -->|8| kafka kafka -->|9| external-notification-service And it generates the following trace: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K","title":"Advanced Selectors"},{"location":"advanced-selectors/#features","text":"","title":"Features"},{"location":"advanced-selectors/#empty-selector","text":"By providing an empty selector, all spans from the trace are selected. Note that an empty selector is an empty string. Providing span or span[] as a selector will result as a syntax error.","title":"Empty Selector"},{"location":"advanced-selectors/#filter-by-attributes","text":"The most basic way of filtering the spans to apply an assertion to is to use the span's attributes. A good starting example would be filtering all spans of type http : span [ tracetest . span . type = \"http\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class D selectedSpan class F selectedSpan class G selectedSpan class I selectedSpan","title":"Filter by Attributes"},{"location":"advanced-selectors/#and-condition","text":"If you need to narrow down your results, you can provide multiple properties in the selector by separating them using a space. The following will select all http spans AND spans that were created by the service cart-api : span [ tracetest . span . type = \"http\" service . name = \"cart-api\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class F selectedSpan","title":"AND Condition"},{"location":"advanced-selectors/#or-condition","text":"Sometimes we want to have a broader result by selecting spans that match different selectors. Let's say we have to get all spans from our services, but not from any other external service. span [ service . name = \"api-product\" ], span [ service . name = \"api-auth\" ], span [ service . name = \"api-notification\" ], span [ service . name = \"api-cart\" ] This would select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class C selectedSpan class D selectedSpan class E selectedSpan class F selectedSpan class G selectedSpan class H selectedSpan class I selectedSpan class J selectedSpan Each span selector will be executed individually and the results will be merged together, creating a list of all spans that match any of the provided span selectors.","title":"OR Condition"},{"location":"advanced-selectors/#contains-operator","text":"Although it is possible to filter several span selectors at once to get a broader result, it might become verbose very quickly. The previous example can be written in another way to reduce its complexity: span [ service . name contains \"api\" ] This would select the same spans as the previous example: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class C selectedSpan class D selectedSpan class E selectedSpan class F selectedSpan class G selectedSpan class H selectedSpan class I selectedSpan class J selectedSpan","title":"Contains Operator"},{"location":"advanced-selectors/#pseudo-classes-support","text":"Sometimes filtering by attributes is not enough because we might have two or three identical spans in the tree but we only want to assert one of them. For example, imagine a system that has a retry policy for all the HTTP requests it sends. How would we allow a user to validate if the third execution was successful without asserting the other two spans? This is where pseudo-classes enter the scene. Pseudo-classes are ways of filtering spans by data that is not present in the span itself. For example, the order which the span appears. Note : Today we support only first , last , and nth_child . If you think we should implement others, please open an issue and explain why it is important and how it should behave. For the examples of the three pseudo-classes, let's consider that we want to select a specific http span based on when it happens. span [ tracetest . span . type = \"http\" ] This will select the following spans: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B selectedSpan class D selectedSpan class F selectedSpan class G selectedSpan class I selectedSpan","title":"Pseudo-classes Support"},{"location":"advanced-selectors/#first","text":"This would return the first appearing span from the list: span [ tracetest . span . type = \"http\" ] : first flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A selectedSpan class B candidateSpan class D candidateSpan class F candidateSpan class G candidateSpan class I candidateSpan","title":":first"},{"location":"advanced-selectors/#last","text":"This would return the last appearing span from the list: span [ tracetest . span . type = \"http\" ] : last flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A candidateSpan class B candidateSpan class D candidateSpan class F candidateSpan class G candidateSpan class I selectedSpan","title":":last"},{"location":"advanced-selectors/#nth_child","text":"This enables you to fetch any item from the list based on its index. n starts at 1 (first element) and ends at length (last element). Any invalid n value will return in an empty list of spans being returned: span [ tracetest . span . type = \"http\" ] : nth_child ( 3 ) flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class A candidateSpan class B candidateSpan class D selectedSpan class F candidateSpan class G candidateSpan class I candidateSpan","title":":nth_child"},{"location":"advanced-selectors/#parent-child-relation-filtering","text":"Even with all those capabilities, we might have problems with ambiguous selectors returning several spans when just a few were intended. In our example, auth-api is called twice from different parts of the trace. At first by product-api and later by cart-api . What if I want to test if a product only available in US can be bought in UK? The product can be seen by the user, but it cannot be bought if the user is outside the US. Certainly, I cannot apply the same assertions on all auth-api spans, otherwise the test will not pass. When you filter by the parent-child relationship, spans are matched recursively in all levels below the parent. This doesn't match only direct children of the parent, but all other spans in the sub-tree. For example: span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] Will return: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef candidateSpan fill:#FF6905, color:#ffffff class D selectedSpan class G selectedSpan This is a problem, because if we apply the same assertion to both spans, one of them will fail. We could try to use nth_child but that could break if a http request failed and the retry policy kicked in. Thus, the only way of filtering in this scenario is based on the context when it was generated. For example: using its parent span to do so. We could use the purchase products parent to ensure just http class to the auth-api triggered by the purchase-api would be selected: span [ service . name = \"cart-api\" , name = \"purchase products\" ] span [ service . name = \"auth-api\" tracetest . span . type = \"http\" ] This would find the parent span and only select the spans that are descedents of that parent and match the provided filter: flowchart TD A[\" id: 1 close order attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] B[\" id: 2 is product available attributes: service.name: product-api tracetest.span.type: http http.method: GET \"] C[\" id: 3 get product information attributes: service.name: product-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] D[\" id: 4 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] E[\" id: 5 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] F[\" id: 6 purchase products attributes: service.name: cart-api tracetest.span.type: http http.method: POST \"] G[\" id: 7 get user can access attributes: service.name: auth-api tracetest.span.type: http http.method: GET \"] H[\" id: 8 get user auth information attributes: service.name: auth-api tracetest.span.type: db db.statement: SELECT * FROM ... \"] I[\" id: 9 notify user attributes: service.name: notification-api tracetest.span.type: http http.method: POST \"] J[\" id: 10 send message to kafka attributes: service.name: notification-api tracetest.span.type: messaging \"] K[\" id: 10 send message to users attributes: service.name: external-service tracetest.span.type: messaging \"] A -->|1| B B -->|2| C B -->|3| D D -->|4| E A -->|5| F F -->|6| G G -->|7| H F -->|8| I I -->|9| J J -->|10| K classDef selectedSpan fill:#439846, color:#ffffff classDef parentSpan fill:#3792cb, color:#ffffff class F parentSpan class G selectedSpan","title":"Parent-child Relation Filtering"},{"location":"architecture/","text":"Architecture The diagram below shows the underlying Tracetest architecture.","title":"Architecture"},{"location":"architecture/#architecture","text":"The diagram below shows the underlying Tracetest architecture.","title":"Architecture"},{"location":"ci-cd-best-practices/","text":"CI/CD Best Practices Read our blog post: Integrating Tracetest with GitHub Actions in a CI pipeline - June 24, 2022","title":"CI/CD Best practices"},{"location":"ci-cd-best-practices/#cicd-best-practices","text":"Read our blog post: Integrating Tracetest with GitHub Actions in a CI pipeline - June 24, 2022","title":"CI/CD Best Practices"},{"location":"command-line-tool/","text":"Command Line Tool Our web interface makes it easier to visualize your traces and add assertions, but sometimes a CLI is needed for automation. The CLI was developed for users creating tests and executing them each time a change is made in the system, so Tracetest can detect regressions and check service SLOs. Available Commands Here is a list of all available commands and how to use them: Configure Configure your CLI to connect to your Tracetest server. How to Use : tracetest configure If you want to set values without having to answer questions from a prompt, you can provide the flags --endpoint to define the server endpoint and --analytics to turn the analytics on and off. # This will prompt a question to ask if you want to enable or not analytics tracetest configure --endpoint http://my-tracetest-server:11633 # Analytics enabled tracetest configure --endpoint http://my-tracetest-server:11633 --analytics # Analytics disabled tracetest configure --endpoint http://my-tracetest-server:11633 --analytics = false Test List Allows you to list all tests. How to Use : tracetest test list Run a Test Allows you to run a test by referencing a test definition file . Note: If the definition file contains the field id , this command will not create a new test. Instead, it will update the test with that ID. If that test doesn't exist, a new one will be created with that ID on the server. Every time the test is run, changes are detected and, if any change is introduced, we use Tractest's versioning mechanism to ensure that it will not cause problems with previous test runs. How to Use : tracetest test run --definition <file-path> Options : --wait-for-result : The CLI will only exit after the test run has completed (the trace was retrieved and assertions were executed).","title":"Command Line Tool"},{"location":"command-line-tool/#command-line-tool","text":"Our web interface makes it easier to visualize your traces and add assertions, but sometimes a CLI is needed for automation. The CLI was developed for users creating tests and executing them each time a change is made in the system, so Tracetest can detect regressions and check service SLOs.","title":"Command Line Tool"},{"location":"command-line-tool/#available-commands","text":"Here is a list of all available commands and how to use them:","title":"Available Commands"},{"location":"command-line-tool/#configure","text":"Configure your CLI to connect to your Tracetest server. How to Use : tracetest configure If you want to set values without having to answer questions from a prompt, you can provide the flags --endpoint to define the server endpoint and --analytics to turn the analytics on and off. # This will prompt a question to ask if you want to enable or not analytics tracetest configure --endpoint http://my-tracetest-server:11633 # Analytics enabled tracetest configure --endpoint http://my-tracetest-server:11633 --analytics # Analytics disabled tracetest configure --endpoint http://my-tracetest-server:11633 --analytics = false","title":"Configure"},{"location":"command-line-tool/#test-list","text":"Allows you to list all tests. How to Use : tracetest test list","title":"Test List"},{"location":"command-line-tool/#run-a-test","text":"Allows you to run a test by referencing a test definition file . Note: If the definition file contains the field id , this command will not create a new test. Instead, it will update the test with that ID. If that test doesn't exist, a new one will be created with that ID on the server. Every time the test is run, changes are detected and, if any change is introduced, we use Tractest's versioning mechanism to ensure that it will not cause problems with previous test runs. How to Use : tracetest test run --definition <file-path> Options : --wait-for-result : The CLI will only exit after the test run has completed (the trace was retrieved and assertions were executed).","title":"Run a Test"},{"location":"create-test/","text":"Create a Test Access the Tracetest application . Click the Create Test button and the Create New Test dialog appears: The option to choose the kind of trigger to initiate the trace is presented: HTTP Request - Create a basic HTTP request. RPC Request - Test and debug your RPC request. Postman Collection - Define your HTTP request via a Postman collection. Choose the trigger and click Next : In this example, HTTP Request has been chosen. Input the Name of the test and the Description or select one of the example provided in the drop down: The Pokemon - List example has been chosen. Then click Next . Add any additional information and click Create : The test will start: When the test is finished, you will get the following results: Please visit the Test Results document for an explanation of viewing the results of a test..","title":"Creating Tests"},{"location":"create-test/#create-a-test","text":"Access the Tracetest application . Click the Create Test button and the Create New Test dialog appears: The option to choose the kind of trigger to initiate the trace is presented: HTTP Request - Create a basic HTTP request. RPC Request - Test and debug your RPC request. Postman Collection - Define your HTTP request via a Postman collection. Choose the trigger and click Next : In this example, HTTP Request has been chosen. Input the Name of the test and the Description or select one of the example provided in the drop down: The Pokemon - List example has been chosen. Then click Next . Add any additional information and click Create : The test will start: When the test is finished, you will get the following results: Please visit the Test Results document for an explanation of viewing the results of a test..","title":"Create a Test"},{"location":"edit-test/","text":"Edit a Test Tracetest enables the update of test details at anytime, if you have to update any of the details regarding the triggering method or the basic details such as name and/or description . This process is really simple and can be achieved from three different places within the app: 1. The home page. 2. The test details page. 3. The Result/Trace page. In any of these pages you'll find a dropdown menu that indicates there are more actions that can be executed for the viewed element. The Edit Form The edit form is composed by the basic details and the request details sections. The basic details section includes the information regarding the test metadata like name, description, test suite (future) . Request details is a changing section depending on which triggering method was used to create the request. For example, if the test was created using the RPC triggering method instead of HTTP, the request details will show different inputs like method, message and metadata . After updating the different information displayed in the form, simply click Save . Every time the test is updated, a new run will be executed with the latest information and the version of the test will increase by one. Then you will be redirected to the run/trace page where you can determine if any of the previous assertions has failed, the trace was changed or other updates from the trace.","title":"Edit a Test"},{"location":"edit-test/#edit-a-test","text":"Tracetest enables the update of test details at anytime, if you have to update any of the details regarding the triggering method or the basic details such as name and/or description . This process is really simple and can be achieved from three different places within the app: 1. The home page. 2. The test details page. 3. The Result/Trace page. In any of these pages you'll find a dropdown menu that indicates there are more actions that can be executed for the viewed element.","title":"Edit a Test"},{"location":"edit-test/#the-edit-form","text":"The edit form is composed by the basic details and the request details sections. The basic details section includes the information regarding the test metadata like name, description, test suite (future) . Request details is a changing section depending on which triggering method was used to create the request. For example, if the test was created using the RPC triggering method instead of HTTP, the request details will show different inputs like method, message and metadata . After updating the different information displayed in the form, simply click Save . Every time the test is updated, a new run will be executed with the latest information and the version of the test will increase by one. Then you will be redirected to the run/trace page where you can determine if any of the previous assertions has failed, the trace was changed or other updates from the trace.","title":"The Edit Form"},{"location":"installing/","text":"Installation TL;DR Install the CLI and use it to setup a server: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/install-cli.sh | bash tracetest server install How It Works Getting started with observability and OpenTelemetry can be complex and overwhelming. It involves different interconected services working together. Our CLI offers an install wizard that helps with the process. It helps not only to setup tracetest itself, but all the tools needed to observe your application. Use the install wizard to install Tracetest locally using Docker Compose or to a local or remote Kubernetes cluster. It installs all the tools required to set up the desired environment and creates all the configurations, tailored to your case. CLI Installation Every time we release a new version of Tracetest, we generate binaries for Linux, MacOS, and Windows. Supporting both amd64, and ARM64 architectures, in tar.gz , deb , rpm and exe formats You can find the latest version here . Linux/MacOS Tracetest CLI can be installed automatically using the following script: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/install-cli.sh | bash It works for systems with Hombrew, apt-get , dpkg , yum , rpm installed, and if no package manager is available, it will try to download the build and install it manually. You can also manually install with one of the following methods Homebrew brew install kubeshop/tracetest/tracetest apt # requirements for our deb repo to work sudo apt-get update && sudo apt-get install -y apt-transport-https ca-certificates # add repo echo \"deb [trusted=yes] https://apt.fury.io/tracetest/ /\" | sudo tee /etc/apt/sources.list.d/fury.list # update and install sudo apt-get update sudo apt-get install tracetest yum # add repository cat <<EOF | $SUDO tee /etc/yum.repos.d/tracetest.repo [tracetest] name=Tracetest baseurl=https://yum.fury.io/tracetest/ enabled=1 gpgcheck=0 EOF # install sudo yum install tracetest --refresh Windows Download one of the files from the latest tag, extract to your machine, and then add the tracetest binary to your PATH variable Server Deployments Docker Compose You can run Tracetest locally using Docker Compose. This setup is great for a development environment. In this form, Tracetest runs in parallel to your Dockerized application, allowing you to interact with your app and its traces, create and run tests over them, etc. Tools required (installed if missing) : - Docker - Docker Compose Requirements : - Jaeger or other compatible backend. If missing, the installer will help you configure one. - OpenTelemetry Collector. If missing, the installer will help you configure one. - A docker-compose.yaml (configurable) file in the project directory. If missing, the installer will create an empty file. Optionals : - PokeShop demo app Result : - tracetest/ directory (configurable) with a docker-compose.yaml and other config files. - Jaeger instance, if selected. - OpenTelemetry Collector , if selected. - PokeShop demo app , if selected. Kubernetes You can run Tracetest in a Kubernetes cluster. This setup is ideal for a CI/CD environment, QA teams working on shared environments, etc. You can use a remote or local (minikube, etc) cluster. We'll even help you setup a local cluster, if you need one. Tools required (installed if missing) : - kubectl - helm If you selected to run locally and want the installer to set up minikube for you: - Docker Requirements : - Jaeger or other compatible backend. If missing, the installer will help you configure one. - OpenTelemetry Collector. If missing, the installer will help you configure one. Optionals : - PokeShop demo app Result : - tracetest helm chart deployed in the tracetest (configurable) namespace. - Jaeger instance deployed in the tracetest namespace, if selected. - Cert Manager , if selected. - Jaeger Operator , if selected. - OpenTelemetry Collector deployed in the tracetest (configurable) namespace, if selected. - PokeShop demo app deployed in the demo namespace, if selected.","title":"Installation"},{"location":"installing/#installation","text":"","title":"Installation"},{"location":"installing/#tldr","text":"Install the CLI and use it to setup a server: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/install-cli.sh | bash tracetest server install","title":"TL;DR"},{"location":"installing/#how-it-works","text":"Getting started with observability and OpenTelemetry can be complex and overwhelming. It involves different interconected services working together. Our CLI offers an install wizard that helps with the process. It helps not only to setup tracetest itself, but all the tools needed to observe your application. Use the install wizard to install Tracetest locally using Docker Compose or to a local or remote Kubernetes cluster. It installs all the tools required to set up the desired environment and creates all the configurations, tailored to your case.","title":"How It Works"},{"location":"installing/#cli-installation","text":"Every time we release a new version of Tracetest, we generate binaries for Linux, MacOS, and Windows. Supporting both amd64, and ARM64 architectures, in tar.gz , deb , rpm and exe formats You can find the latest version here .","title":"CLI Installation"},{"location":"installing/#linuxmacos","text":"Tracetest CLI can be installed automatically using the following script: curl -L https://raw.githubusercontent.com/kubeshop/tracetest/main/install-cli.sh | bash It works for systems with Hombrew, apt-get , dpkg , yum , rpm installed, and if no package manager is available, it will try to download the build and install it manually. You can also manually install with one of the following methods","title":"Linux/MacOS"},{"location":"installing/#homebrew","text":"brew install kubeshop/tracetest/tracetest","title":"Homebrew"},{"location":"installing/#apt","text":"# requirements for our deb repo to work sudo apt-get update && sudo apt-get install -y apt-transport-https ca-certificates # add repo echo \"deb [trusted=yes] https://apt.fury.io/tracetest/ /\" | sudo tee /etc/apt/sources.list.d/fury.list # update and install sudo apt-get update sudo apt-get install tracetest","title":"apt"},{"location":"installing/#yum","text":"# add repository cat <<EOF | $SUDO tee /etc/yum.repos.d/tracetest.repo [tracetest] name=Tracetest baseurl=https://yum.fury.io/tracetest/ enabled=1 gpgcheck=0 EOF # install sudo yum install tracetest --refresh","title":"yum"},{"location":"installing/#windows","text":"Download one of the files from the latest tag, extract to your machine, and then add the tracetest binary to your PATH variable","title":"Windows"},{"location":"installing/#server-deployments","text":"","title":"Server Deployments"},{"location":"installing/#docker-compose","text":"You can run Tracetest locally using Docker Compose. This setup is great for a development environment. In this form, Tracetest runs in parallel to your Dockerized application, allowing you to interact with your app and its traces, create and run tests over them, etc. Tools required (installed if missing) : - Docker - Docker Compose Requirements : - Jaeger or other compatible backend. If missing, the installer will help you configure one. - OpenTelemetry Collector. If missing, the installer will help you configure one. - A docker-compose.yaml (configurable) file in the project directory. If missing, the installer will create an empty file. Optionals : - PokeShop demo app Result : - tracetest/ directory (configurable) with a docker-compose.yaml and other config files. - Jaeger instance, if selected. - OpenTelemetry Collector , if selected. - PokeShop demo app , if selected.","title":"Docker Compose"},{"location":"installing/#kubernetes","text":"You can run Tracetest in a Kubernetes cluster. This setup is ideal for a CI/CD environment, QA teams working on shared environments, etc. You can use a remote or local (minikube, etc) cluster. We'll even help you setup a local cluster, if you need one. Tools required (installed if missing) : - kubectl - helm If you selected to run locally and want the installer to set up minikube for you: - Docker Requirements : - Jaeger or other compatible backend. If missing, the installer will help you configure one. - OpenTelemetry Collector. If missing, the installer will help you configure one. Optionals : - PokeShop demo app Result : - tracetest helm chart deployed in the tracetest (configurable) namespace. - Jaeger instance deployed in the tracetest namespace, if selected. - Cert Manager , if selected. - Jaeger Operator , if selected. - OpenTelemetry Collector deployed in the tracetest (configurable) namespace, if selected. - PokeShop demo app deployed in the demo namespace, if selected.","title":"Kubernetes"},{"location":"introduction/","text":"Introduction to Trace-Based Testing Trace-Based Testing is a means of conducting deep integration or system tests by utilizing the rich data contained in a distributed system trace. What is a Distributed Trace? A Distributed Trace, more commonly known as a Trace, records the paths taken by requests (made by an application or end-user) take as they propagate through multi-service architectures, like microservice and serverless applications. Source - OpenTelemetry.io What is a Span? Traces are comprised of spans. A span represents a single operation in a trace. Spans are nested, typically with a parent child relationship to form a deeply nested tree. What Data do Spans Contain? A span contains the data about the operation it represents. This data includes: The span name. Start and end timestamp. List of events (if instrumented). Attributes What are Attributes? Attributes are a key-value pair, and they contain information about the operation. A developer can manually add additional attributes to a span, enriching the data. There are Semantic Conventions that provide recommended names for the attributes for common types of calls such as database, http, messaging, etc. What is a Test Spec? In Tracetest, an Test Spec is comprised of two parts: Selector Checks What is a Selector? A selector contains criteria to limit the scope of the spans from a trace that we wish to assert against. A selector can be very narrow, only selecting on one span, or very wide, selecting all spans or all spans of a certain type or other characteristics. Underlying this capability is a selector language . What is a Check? A check is a logical verification that will be performed on all spans that match the selector. It is comprised of an attribute, a comparison operator, and a value. What is a Span Signature? A span signature is an automatically computed selector that has enough elements to specify a single span. It uses a combination of attributes in the selected span to automatically build the selector. If a trace has multiple spans that are almost identical, the span signature may still match more than one span. You can alter the selector in this case to be more specific by adding other attributes or specifying an ancestor span.","title":"Introduction to Trace-Based Testing"},{"location":"introduction/#introduction-to-trace-based-testing","text":"Trace-Based Testing is a means of conducting deep integration or system tests by utilizing the rich data contained in a distributed system trace.","title":"Introduction to Trace-Based Testing"},{"location":"introduction/#what-is-a-distributed-trace","text":"A Distributed Trace, more commonly known as a Trace, records the paths taken by requests (made by an application or end-user) take as they propagate through multi-service architectures, like microservice and serverless applications. Source - OpenTelemetry.io","title":"What is a Distributed Trace?"},{"location":"introduction/#what-is-a-span","text":"Traces are comprised of spans. A span represents a single operation in a trace. Spans are nested, typically with a parent child relationship to form a deeply nested tree.","title":"What is a Span?"},{"location":"introduction/#what-data-do-spans-contain","text":"A span contains the data about the operation it represents. This data includes: The span name. Start and end timestamp. List of events (if instrumented). Attributes","title":"What Data do Spans Contain?"},{"location":"introduction/#what-are-attributes","text":"Attributes are a key-value pair, and they contain information about the operation. A developer can manually add additional attributes to a span, enriching the data. There are Semantic Conventions that provide recommended names for the attributes for common types of calls such as database, http, messaging, etc.","title":"What are Attributes?"},{"location":"introduction/#what-is-a-test-spec","text":"In Tracetest, an Test Spec is comprised of two parts: Selector Checks","title":"What is a Test Spec?"},{"location":"introduction/#what-is-a-selector","text":"A selector contains criteria to limit the scope of the spans from a trace that we wish to assert against. A selector can be very narrow, only selecting on one span, or very wide, selecting all spans or all spans of a certain type or other characteristics. Underlying this capability is a selector language .","title":"What is a Selector?"},{"location":"introduction/#what-is-a-check","text":"A check is a logical verification that will be performed on all spans that match the selector. It is comprised of an attribute, a comparison operator, and a value.","title":"What is a Check?"},{"location":"introduction/#what-is-a-span-signature","text":"A span signature is an automatically computed selector that has enough elements to specify a single span. It uses a combination of attributes in the selected span to automatically build the selector. If a trace has multiple spans that are almost identical, the span signature may still match more than one span. You can alter the selector in this case to be more specific by adding other attributes or specifying an ancestor span.","title":"What is a Span Signature?"},{"location":"openapi/","text":"SwaggerUIBundle({ url: 'https://raw.githubusercontent.com/kubeshop/tracetest/main/api/openapi.yaml', dom_id: '#swagger-ui', })","title":"OpenAPI Definition"},{"location":"pokeshop/","text":"Pokeshop Microservice API (PMA) As a testing ground, the team at Tracetest has implemented a sample instrumented API around the PokeAPI . The idea is to have a microservice-divided system that could behave like a typical scenario by having async processes (RabbitMQ), cache layers (Redis), database storage (Postgres), and simple CRUD interfaces for Pokemons. With this, users can get familiar with the Tracetest tool by focusing on creating assertions, visualizing the trace, and identifying the different data that comes from the Collector (Jeager). Users will learn about basic instrumentation practices like what tools to use, what data to send, when, and what suggested standards need to be followed. The PMA is only accessible from within the Kubernetes cluster network as the Tracetest needs to be able to reach it. System architecture","title":"Overview"},{"location":"pokeshop/#pokeshop-microservice-api-pma","text":"As a testing ground, the team at Tracetest has implemented a sample instrumented API around the PokeAPI . The idea is to have a microservice-divided system that could behave like a typical scenario by having async processes (RabbitMQ), cache layers (Redis), database storage (Postgres), and simple CRUD interfaces for Pokemons. With this, users can get familiar with the Tracetest tool by focusing on creating assertions, visualizing the trace, and identifying the different data that comes from the Collector (Jeager). Users will learn about basic instrumentation practices like what tools to use, what data to send, when, and what suggested standards need to be followed. The PMA is only accessible from within the Kubernetes cluster network as the Tracetest needs to be able to reach it.","title":"Pokeshop Microservice API (PMA)"},{"location":"pokeshop/#system-architecture","text":"","title":"System architecture"},{"location":"run-affected-spans/","text":"Affected Spans As you might know, Tracetest assertions are composed of two main parts: 1. A selector. 2. List of checks. The selector is used to identify which spans will be affected by the assertion and the system can apply the different checks. To help the process of visually identifying what spans will be affected, Tracetest highlights them and obscures the rest while either creating/editing an assertion or selecting an existing one from the test results panel. Creating an Assertion When updating the different key value pairs to narrow down the specific span, a new control will be displayed at the top left section of the Diagram view, which has the option to move across the different affected spans. At the same time, this control component will be displayed at the assertion form level; where the user has the same options to move across the affected spans and have a visual indication of what exactly is happening. Selecting an Existing Assertion By opening the Test Result bottom section, you can find the different assertions and, when clicking on any of them, the affected spans will be automatically highlighted and the controls will be displayed at the top left of the diagram. Selecting an Assertion Diagram View","title":"Affected Spans"},{"location":"run-affected-spans/#affected-spans","text":"As you might know, Tracetest assertions are composed of two main parts: 1. A selector. 2. List of checks. The selector is used to identify which spans will be affected by the assertion and the system can apply the different checks. To help the process of visually identifying what spans will be affected, Tracetest highlights them and obscures the rest while either creating/editing an assertion or selecting an existing one from the test results panel.","title":"Affected Spans"},{"location":"run-affected-spans/#creating-an-assertion","text":"When updating the different key value pairs to narrow down the specific span, a new control will be displayed at the top left section of the Diagram view, which has the option to move across the different affected spans. At the same time, this control component will be displayed at the assertion form level; where the user has the same options to move across the affected spans and have a visual indication of what exactly is happening.","title":"Creating an Assertion"},{"location":"run-affected-spans/#selecting-an-existing-assertion","text":"By opening the Test Result bottom section, you can find the different assertions and, when clicking on any of them, the affected spans will be automatically highlighted and the controls will be displayed at the top left of the diagram. Selecting an Assertion Diagram View","title":"Selecting an Existing Assertion"},{"location":"run-exports/","text":"Edit a Test Tracetest allows you to export the different set of information displayed for assertions and checks in a way you can use it as input for other tools, create text based tests to use on your CI/CD pipelines using the CLI and more options. The current supported exports are: 1. JUnit results XML. 2. Test Definition YAML. To access any of the available exports, go to the run/trace page details for any test and, at the header level, you'll find a three dot menu which will display the options. JUnit Results XML To access the JUnit XML file, select the JUnit option from the dropdown and you'll find the file viewer modal with the location to download the file. The JUnit report contains the results from each of the assertions added to the test and their statuses. Depending on how many assertions the test has, this file will grow. Test Definition YAML The Tracetest CLI allows you to execute text based tests. This means you can store all of your tests in a repo, keep track of the different versions and use them for your CI/CD process. An easy way to start is to export the test definition directly from the UI by selecting the option from the dropdown. The file viewer modal will popup where you can copy paste or download the file.","title":"Edit a Test"},{"location":"run-exports/#edit-a-test","text":"Tracetest allows you to export the different set of information displayed for assertions and checks in a way you can use it as input for other tools, create text based tests to use on your CI/CD pipelines using the CLI and more options. The current supported exports are: 1. JUnit results XML. 2. Test Definition YAML. To access any of the available exports, go to the run/trace page details for any test and, at the header level, you'll find a three dot menu which will display the options.","title":"Edit a Test"},{"location":"run-exports/#junit-results-xml","text":"To access the JUnit XML file, select the JUnit option from the dropdown and you'll find the file viewer modal with the location to download the file. The JUnit report contains the results from each of the assertions added to the test and their statuses. Depending on how many assertions the test has, this file will grow.","title":"JUnit Results XML"},{"location":"run-exports/#test-definition-yaml","text":"The Tracetest CLI allows you to execute text based tests. This means you can store all of your tests in a repo, keep track of the different versions and use them for your CI/CD process. An easy way to start is to export the test definition directly from the UI by selecting the option from the dropdown. The file viewer modal will popup where you can copy paste or download the file.","title":"Test Definition YAML"},{"location":"run-locally/","text":"Run Tracetest Locally Tracetest depends on a postgres database and a trace store backend (Jaeger or Tempo). The frontend requires node and npm and the backend requires the go tooling. Run on Local Kubernetes Tracetest and its dependencies can be installed in a local Kubernetes cluster (microk8s, minikube, Kubernetes for Docker Desktop, etc). Following the install steps will install a running instance of Tracetest and Postgres. Installing Jaeger is the easiest way to get a trace store backend. The Tracetest install can be exposed with a LoadBalancer , NodePort or any similar mechanism. It can also be kept internally, only expose the Jaeger and postgres port, and use them to run local development builds. This is useful to quickly test changes on both the front and back end. Installing Jaeger Before installing Tracetest, we need to setup the Jaeger operator , which in turn has a dependency on cert-mnanager . cert-manager has different install options . The simplest way to do this is to use a static install: $ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml Once the pods in cert-manager namespace are running, we can install the Jaeger operator: kubectl create namespace observability kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.32.0/jaeger-operator.yaml -n observability Now, create an AllInOne jaeger instance: cat <<EOF | kubectl create -f - apiVersion: jaegertracing.io/v1 kind: Jaeger metadata: name: jaeger EOF Install Tracetest Follow the install steps : helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set telemetry.dataStores.jaeger.jaeger.endpoint = \"jaeger-query:16685\" \\ # update this value to point to your jaeger install --set telemetry.exporters.collector.exporter.collector.endpoint = \"otel-collector:4317\" \\ # update this value to point to your collector install --set server.telemetry.dataStore = \"jaeger\" You can now expose the Tracetest service using a LoadBalancer , NodePort or even a simple port-forward : kubectl port-forward svc/tracetest 11633:11633 Now Tracetest is available at [http://localhost:11633] Run a Development Build Now that Tracetest is running, we can expose the dependencies in our cluster to the host machine so they are accessible to the development build. Tracetests needs postgres to store the tests, results, etc, and access to the trace backend (jaeger, tempo, etc) to fetch traces. We can use kubectl's port forwarding capabilites for this (trap \"kill 0\" SIGINT; kubectl port-forward svc/tracetest-postgresql 5432:5432 & kubectl port-forward svc/jaeger-query 16685:16685) Start Development Server When running the development version, the frontend and backend are built and run separately. You need to have both services running to access the tool. To start the backend server: make server-run To start the frontend server: cd web npm install -d npm start The Tracetest development build is available at [http://localhost:3000]. Note that the port is now 3000 since we are accessing the node development server.","title":"Run Tracetest Locally"},{"location":"run-locally/#run-tracetest-locally","text":"Tracetest depends on a postgres database and a trace store backend (Jaeger or Tempo). The frontend requires node and npm and the backend requires the go tooling.","title":"Run Tracetest Locally"},{"location":"run-locally/#run-on-local-kubernetes","text":"Tracetest and its dependencies can be installed in a local Kubernetes cluster (microk8s, minikube, Kubernetes for Docker Desktop, etc). Following the install steps will install a running instance of Tracetest and Postgres. Installing Jaeger is the easiest way to get a trace store backend. The Tracetest install can be exposed with a LoadBalancer , NodePort or any similar mechanism. It can also be kept internally, only expose the Jaeger and postgres port, and use them to run local development builds. This is useful to quickly test changes on both the front and back end.","title":"Run on Local Kubernetes"},{"location":"run-locally/#installing-jaeger","text":"Before installing Tracetest, we need to setup the Jaeger operator , which in turn has a dependency on cert-mnanager . cert-manager has different install options . The simplest way to do this is to use a static install: $ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml Once the pods in cert-manager namespace are running, we can install the Jaeger operator: kubectl create namespace observability kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.32.0/jaeger-operator.yaml -n observability Now, create an AllInOne jaeger instance: cat <<EOF | kubectl create -f - apiVersion: jaegertracing.io/v1 kind: Jaeger metadata: name: jaeger EOF","title":"Installing Jaeger"},{"location":"run-locally/#install-tracetest","text":"Follow the install steps : helm repo add kubeshop https://kubeshop.github.io/helm-charts helm repo update helm install tracetest kubeshop/tracetest \\ --set telemetry.dataStores.jaeger.jaeger.endpoint = \"jaeger-query:16685\" \\ # update this value to point to your jaeger install --set telemetry.exporters.collector.exporter.collector.endpoint = \"otel-collector:4317\" \\ # update this value to point to your collector install --set server.telemetry.dataStore = \"jaeger\" You can now expose the Tracetest service using a LoadBalancer , NodePort or even a simple port-forward : kubectl port-forward svc/tracetest 11633:11633 Now Tracetest is available at [http://localhost:11633]","title":"Install Tracetest"},{"location":"run-locally/#run-a-development-build","text":"Now that Tracetest is running, we can expose the dependencies in our cluster to the host machine so they are accessible to the development build. Tracetests needs postgres to store the tests, results, etc, and access to the trace backend (jaeger, tempo, etc) to fetch traces. We can use kubectl's port forwarding capabilites for this (trap \"kill 0\" SIGINT; kubectl port-forward svc/tracetest-postgresql 5432:5432 & kubectl port-forward svc/jaeger-query 16685:16685)","title":"Run a Development Build"},{"location":"run-locally/#start-development-server","text":"When running the development version, the frontend and backend are built and run separately. You need to have both services running to access the tool. To start the backend server: make server-run To start the frontend server: cd web npm install -d npm start The Tracetest development build is available at [http://localhost:3000]. Note that the port is now 3000 since we are accessing the node development server.","title":"Start Development Server"},{"location":"run-text-search/","text":"Text Search Tracetest enables you to find the information you need more easily by using the text search input at the top of the Diagram view. You can type text into the search and the app will try to match it with any span attribute key and value while highlighting the options for you. To use this feature, go to the any run details page and identify the search input. Then simply add any text you want to look for. Search for 'http': Match the 'insert into' statement:","title":"Text Search"},{"location":"run-text-search/#text-search","text":"Tracetest enables you to find the information you need more easily by using the text search input at the top of the Diagram view. You can type text into the search and the app will try to match it with any span attribute key and value while highlighting the options for you. To use this feature, go to the any run details page and identify the search input. Then simply add any text you want to look for. Search for 'http': Match the 'insert into' statement:","title":"Text Search"},{"location":"server-configuration/","text":"Server configuration Tracetest can be configured using a config.yaml file placed on the same directory as its executable. It is useful to configure some aspects of how tracetest should behave. This section is dedicated to explain the options we currently have available. Configuration file example # Connection string to the postgres instance postgresConnString : \"host=localhost user=postgres password=postgres port=5432 sslmode=disable\" # Instance of jaeger that will be used to retrieve the trace of the service under test tracingBackend : dataStore : type : jaeger jaeger : endpoint : localhost:16685 tls : insecure : true # Configure how traces should be pooled from the tracing storage. poolingConfig : # How long tracetest can wait for a trace to be complete? After this period, the pooling process will timeout # and the test will be marked as failed. maxWaitTimeForTrace : 90s # How much time tracetest should wait before trying to fetch the trace since the last execution? retryDelay : 5s # Server configuration server : # Enables you to add a prefix to the server path. So, instead of running tracetest on http://localhost:11633, it would run on http://localhost:11633/tracetest instead. pathPrefix : /tracetest httpPort : 11633 # Google analytics configuration googleAnalytics : enabled : false measurementId : \"\" secretKey : \"\" # How tracetest should generate telemetry data. telemetry : serviceName : tracetest sampling : 100 otelCollectorEndpoint : localhost:4317 Providing a configuration when running a container docker run --volume \"`pwd`/my-config-file.yaml:/app/config.yaml\" kubeshop/tracetest","title":"Server configuration"},{"location":"server-configuration/#server-configuration","text":"Tracetest can be configured using a config.yaml file placed on the same directory as its executable. It is useful to configure some aspects of how tracetest should behave. This section is dedicated to explain the options we currently have available.","title":"Server configuration"},{"location":"server-configuration/#configuration-file-example","text":"# Connection string to the postgres instance postgresConnString : \"host=localhost user=postgres password=postgres port=5432 sslmode=disable\" # Instance of jaeger that will be used to retrieve the trace of the service under test tracingBackend : dataStore : type : jaeger jaeger : endpoint : localhost:16685 tls : insecure : true # Configure how traces should be pooled from the tracing storage. poolingConfig : # How long tracetest can wait for a trace to be complete? After this period, the pooling process will timeout # and the test will be marked as failed. maxWaitTimeForTrace : 90s # How much time tracetest should wait before trying to fetch the trace since the last execution? retryDelay : 5s # Server configuration server : # Enables you to add a prefix to the server path. So, instead of running tracetest on http://localhost:11633, it would run on http://localhost:11633/tracetest instead. pathPrefix : /tracetest httpPort : 11633 # Google analytics configuration googleAnalytics : enabled : false measurementId : \"\" secretKey : \"\" # How tracetest should generate telemetry data. telemetry : serviceName : tracetest sampling : 100 otelCollectorEndpoint : localhost:4317","title":"Configuration file example"},{"location":"server-configuration/#providing-a-configuration-when-running-a-container","text":"docker run --volume \"`pwd`/my-config-file.yaml:/app/config.yaml\" kubeshop/tracetest","title":"Providing a configuration when running a container"},{"location":"supported-backends/","text":"Supported Backends Currently, Tracetest supports the following backend data stores: Jaeger Grafana Tempo OpenSearch SignalFX Details of configuring Tracetest to access these is discussed in the installation instructions . We will be adding new data stores over the next couple of months - let us know the ones you would to see us add support for. Using Tracetest Without a Backend Another option is to not use a backend and send all traces directly to Tracetest using your OpenTelemetry Collector. And, you don't have to change your existing pipelines to do so. Configuring Your Collector to Send Traces to Tracetest It is important to notice that this relies on the tailsampling processor, which, at the moment, is only available in the contrib version of the collector. Creating a New Pipeline for Your Traces # your collector configuration file # If you already have receivers declared, you can just ignore # this one and still use yours instead. receivers : otlp : protocols : grpc : http : processors : # you will need to add this processor in order to only send spans # generated by tests to your Tracetest instance. tail_sampling : decision_wait : 5s policies : - name : tracetest-spans type : trace_state trace_state : { key : tracetest , values : [ \"true\" ] } exporters : # This is the exporter that will send traces to Tracetest otlp/1 : endpoint : http://your-tracetest-instance.com:21321 tls : insecure : true batch : service : pipelines : # your probably already have a traces pipeline, you don't have to change it. # just add this one to your configuration. Just make sure to not have two # pipelines with the same name traces/1 : receivers : [ otlp ] # your receiver processors : [ tail_sampling , batch ] # make sure to have the tail_sampling before your batch processor exporters : [ otlp/1 ] # your exporter pointing to your tracetest instance Configuring your Tracetest Instance You also have to configure your Tracetest instance to make it aware that there's no tracing backend to pull traces from. Just change your configuration file to include this configuration: # your tracetest config YAML file telemetry : dataStores : otlp : type : otlp # rest of your telemetry configuration server : telemetry : dataStore : otlp # rest of the configuration file","title":"Supported Backends"},{"location":"supported-backends/#supported-backends","text":"Currently, Tracetest supports the following backend data stores: Jaeger Grafana Tempo OpenSearch SignalFX Details of configuring Tracetest to access these is discussed in the installation instructions . We will be adding new data stores over the next couple of months - let us know the ones you would to see us add support for.","title":"Supported Backends"},{"location":"supported-backends/#using-tracetest-without-a-backend","text":"Another option is to not use a backend and send all traces directly to Tracetest using your OpenTelemetry Collector. And, you don't have to change your existing pipelines to do so.","title":"Using Tracetest Without a Backend"},{"location":"supported-backends/#configuring-your-collector-to-send-traces-to-tracetest","text":"It is important to notice that this relies on the tailsampling processor, which, at the moment, is only available in the contrib version of the collector.","title":"Configuring Your Collector to Send Traces to Tracetest"},{"location":"supported-backends/#creating-a-new-pipeline-for-your-traces","text":"# your collector configuration file # If you already have receivers declared, you can just ignore # this one and still use yours instead. receivers : otlp : protocols : grpc : http : processors : # you will need to add this processor in order to only send spans # generated by tests to your Tracetest instance. tail_sampling : decision_wait : 5s policies : - name : tracetest-spans type : trace_state trace_state : { key : tracetest , values : [ \"true\" ] } exporters : # This is the exporter that will send traces to Tracetest otlp/1 : endpoint : http://your-tracetest-instance.com:21321 tls : insecure : true batch : service : pipelines : # your probably already have a traces pipeline, you don't have to change it. # just add this one to your configuration. Just make sure to not have two # pipelines with the same name traces/1 : receivers : [ otlp ] # your receiver processors : [ tail_sampling , batch ] # make sure to have the tail_sampling before your batch processor exporters : [ otlp/1 ] # your exporter pointing to your tracetest instance","title":"Creating a New Pipeline for Your Traces"},{"location":"supported-backends/#configuring-your-tracetest-instance","text":"You also have to configure your Tracetest instance to make it aware that there's no tracing backend to pull traces from. Just change your configuration file to include this configuration: # your tracetest config YAML file telemetry : dataStores : otlp : type : otlp # rest of your telemetry configuration server : telemetry : dataStore : otlp # rest of the configuration file","title":"Configuring your Tracetest Instance"},{"location":"test-definition-file/","text":"Defining Tests as Text Files One important aspect of testing your code is the ability to quickly implement changes while not breaking your application. If you change your application, it is important that you are able to update your tests and run them against your new implementation as soon as possible for a timely development feedback loop. As Tracetest is mainly a visual tool, this might make it difficult to update tests in an auditable way and execute those changes only when we are sure the application has been deployed with the new changes. With that in mind, we built a new way for you to define your tests: using a YAML test definition! Motivation Imagine that you were assigned a ticket to improve your application database usage. You notice that every time a specific endpoint is called, your application executes N+1 select statements on the database instead of only one statement. You probably already have a test in place to ensure the correct functionality of that endpoint: it inserts the necessary information into the database, calls that specific endpoint using our tool and ensures you get the expected results using the trace generated by your application. It works fine, but there is a problem. That test is managed by Tracetest on its server and the test cannot be changed until the new patch is deployed. Otherwise, if the test is run using a non-patched version of the application, the test would fail. To solve that, the best approach would be to enable developers to define their tests as text files and allow them to run those tests using a CLI, so you can integrate the execution of those tests to your existing CI pipeline. There are many benefits of this functionality for your tests: - Peers can review your tests before merging them to the main branch. - Ensure your test works before merging it to the main branch. - Have different versions of the same test running in parallel in different branches, so you and your peers can work on the same code modules and update the same test without interfering with each other. Definition The definition can be broken into three parts: test information , triggering transaction , and assertions . Here is a real test we have on Tracetest to test our Pokemon demo api: name : POST import pokemon trigger : type : http httpRequest : url : http://demo-pokemon-api.demo/pokemon/import method : POST headers : - key : Content-Type value : application/json body : '{ \"id\": 52 }' specs : - selector : span[name = \"POST /pokemon/import\"] assertions : - tracetest.span.duration <= 500ms - http.status_code = 200 - selector : span[name = \"send message to queue\"] assertions : - messaging.message.payload contains 52 - selector : span[name = \"consume message from queue\"]:last assertions : - messaging.message.payload contains 52 - selector : span[name = \"consume message from queue\"]:last span[name = \"import pokemon from pokeapi\"] assertions : - http.status_code = 200 - selector : span[name = \"consume message from queue\"]:last span[name = \"save pokemon on database\"] assertions : - db.repository.operation = \"create\" - tracetest.span.duration <= 500ms Test Information Currently, you can only define the test name. Trigger This section defines how Tracetest will interact with your application: send an HTTP request, a GRPC call, send a message to a message broker, etc. Currently, only HTTP calls are supported, please let us know any other triggering mechanism that you require to test your application. The attribute type defines which trigger method you are going to use to interact with your application. The rest of the attributes in this section rely on the value you define there. HTTP Trigger When defining a HTTP trigger, you are required to define a httpRequest object containing the request Tracetest will send to your system, so here you can define: url , method , headers , authentication , and body . Note: Some APIs require the Content-Type header to respond. If you are not able to trigger your application, check if you are sending this header and if its value is correct. trigger : type : http httpRequest : url : http://demo-pokemon-api.demo/pokemon/import method : POST headers : - key : Content-Type value : application/json body : '{ \"id\": 52 }' Authentication Currently, we support three authentication methods for HTTP requests: basic authentication , api key , and bearer token . Here is one example of each authentication method: Basic Authentication trigger : type : http httpRequest : url : http://my-api.com method : GET authentication : type : basic basic : user : my-username password : mypassword API Key Authentication trigger : type : http httpRequest : url : http://my-api.com method : GET authentication : type : apiKey apiKey : key : X-Key value : my-key in : header # Either \"header\" or \"query\" Bearer Token Authentication trigger : type : http httpRequest : url : http://my-api.com method : GET authentication : type : bearer bearer : token : my-token Body Currently, Testkube supports raw body types that enable you to send text formats over HTTP, for example: JSON. trigger : type : http httpRequest : url : http://my-api.com method : POST body : '{\"name\": \"my Json Object\"}' Generator Functions Sometimes we want to randomize our test data. Maybe we want to try new values or maybe we know our API will fail if the same id is provided more than once. For this use case, you can define generator functions in the test trigger. To use a generator function, wrap it in double curly brackets: {{ uuid() }} . Available functions: Function Description uuid() Generates a random v4 uuid. firstName() Generates a random English first name. lastName() Generates a random English last name. fullName() Generates a random English first and last name. email() Generates a random email address. phone() Generates a random phone number. creditCard() Generates a random credit card number (from 12 to 19 digits). creditCardCvv() Generates a random credit card cvv (3 digits). creditCardExpDate() Generates a random credit card expiration date (mm/yy). randomInt(min, max) Generates a random integer contained in the closed interval defined by [ min , max ]. Assertions Assertions are as important as how you trigger your test. Without them, your test is just a fancy way of executing a request using a CLI command. In this section, we will discuss how you can declare your assertions in your definition file. Before we start, there are two concepts that you must understand to write your tests: selectors and assertions. Selectors are queries that are executed against your trace tree and select a set of spans based on some attributes. They are responsible for defining which spans will be tested against your assertions. Assertions are tests against a specific span based on its attributes. A practical example might be useful: Imagine you have to ensure that all your database select statements take less than 500ms . To write a test for that you must: Select all spans in your trace related to select statements . Check if all those spans lasted less than 500ms . For the first task, we use a selector: span[db.statement contains \"SELECT\"] . While the second one is achieved by using an assertion: tracetest.span.duration < 500ms . Note: When asserting time fields, you can use the following time units: ns (nanoseconds), us (microseconds), ms (milliseconds), s (seconds), m (minutes), and h (hours). Instead of defining tracetest.span.duration <= 3600s , you can set it as tracetest.span.duration <= 1h . To write that in your test definition, you can define the following YAML definition: specs : - selector : span[db.statement contains \"SELECT\"] assertions : - tracetest.span.duration < 500ms As you probably noticed in the test definition structure, you can have multiple assertions for the same selector. This is useful to group related validations. For example, ensuring that all your HTTP calls are successful and take less than 1000ms: specs : - selector : span[tracetest.span.type=\"http\"] assertions : - http.status_code >= 200 - http.status_code < 300 - tracetest.span.duration < 1000ms Referencing Other Fields from the Same Span You also can reference fields from the same span in your assertions. For example, you can define an assertion to ensure the output number is greater than the input number. testDefinition : - selector : span[name = \"my operation\"] assertions : - myapp.output > myapp.input You also can use basic arithmetic expressions in your assertions: assertions : - myapp.output = myapp.input + 1 Note: This does not take into account the order of operators yet. So an expression 1 + 2 * 3 will be resolved as 9 instead of 7 . This will be fixed in future releases. Available operations in an expression are: + , - , * , and / . For more information about selectors or assertions, take a look at the documentation for those topics. Available Operations Operator Description = Check if two values are equal. != Check if two values have different values. < Check if value from left side is smaller than the one on the right side of the operation. <= Check if value from left side is smaller or equal to the one on the right side of the operation. > Check if value from left side is larger than the one on the right side of the operation. >= Check if value from left side is larger or equal to the one on the right side of the operation. contains Check if value on the right side of the operation is contained inside of the value of the left side of the operation. not-contains Check if value on the right side of the operation is not contained inside of the value of the left side of the operation.","title":"Test Definition File"},{"location":"test-definition-file/#defining-tests-as-text-files","text":"One important aspect of testing your code is the ability to quickly implement changes while not breaking your application. If you change your application, it is important that you are able to update your tests and run them against your new implementation as soon as possible for a timely development feedback loop. As Tracetest is mainly a visual tool, this might make it difficult to update tests in an auditable way and execute those changes only when we are sure the application has been deployed with the new changes. With that in mind, we built a new way for you to define your tests: using a YAML test definition!","title":"Defining Tests as Text Files"},{"location":"test-definition-file/#motivation","text":"Imagine that you were assigned a ticket to improve your application database usage. You notice that every time a specific endpoint is called, your application executes N+1 select statements on the database instead of only one statement. You probably already have a test in place to ensure the correct functionality of that endpoint: it inserts the necessary information into the database, calls that specific endpoint using our tool and ensures you get the expected results using the trace generated by your application. It works fine, but there is a problem. That test is managed by Tracetest on its server and the test cannot be changed until the new patch is deployed. Otherwise, if the test is run using a non-patched version of the application, the test would fail. To solve that, the best approach would be to enable developers to define their tests as text files and allow them to run those tests using a CLI, so you can integrate the execution of those tests to your existing CI pipeline. There are many benefits of this functionality for your tests: - Peers can review your tests before merging them to the main branch. - Ensure your test works before merging it to the main branch. - Have different versions of the same test running in parallel in different branches, so you and your peers can work on the same code modules and update the same test without interfering with each other.","title":"Motivation"},{"location":"test-definition-file/#definition","text":"The definition can be broken into three parts: test information , triggering transaction , and assertions . Here is a real test we have on Tracetest to test our Pokemon demo api: name : POST import pokemon trigger : type : http httpRequest : url : http://demo-pokemon-api.demo/pokemon/import method : POST headers : - key : Content-Type value : application/json body : '{ \"id\": 52 }' specs : - selector : span[name = \"POST /pokemon/import\"] assertions : - tracetest.span.duration <= 500ms - http.status_code = 200 - selector : span[name = \"send message to queue\"] assertions : - messaging.message.payload contains 52 - selector : span[name = \"consume message from queue\"]:last assertions : - messaging.message.payload contains 52 - selector : span[name = \"consume message from queue\"]:last span[name = \"import pokemon from pokeapi\"] assertions : - http.status_code = 200 - selector : span[name = \"consume message from queue\"]:last span[name = \"save pokemon on database\"] assertions : - db.repository.operation = \"create\" - tracetest.span.duration <= 500ms","title":"Definition"},{"location":"test-definition-file/#test-information","text":"Currently, you can only define the test name.","title":"Test Information"},{"location":"test-definition-file/#trigger","text":"This section defines how Tracetest will interact with your application: send an HTTP request, a GRPC call, send a message to a message broker, etc. Currently, only HTTP calls are supported, please let us know any other triggering mechanism that you require to test your application. The attribute type defines which trigger method you are going to use to interact with your application. The rest of the attributes in this section rely on the value you define there.","title":"Trigger"},{"location":"test-definition-file/#http-trigger","text":"When defining a HTTP trigger, you are required to define a httpRequest object containing the request Tracetest will send to your system, so here you can define: url , method , headers , authentication , and body . Note: Some APIs require the Content-Type header to respond. If you are not able to trigger your application, check if you are sending this header and if its value is correct. trigger : type : http httpRequest : url : http://demo-pokemon-api.demo/pokemon/import method : POST headers : - key : Content-Type value : application/json body : '{ \"id\": 52 }'","title":"HTTP Trigger"},{"location":"test-definition-file/#authentication","text":"Currently, we support three authentication methods for HTTP requests: basic authentication , api key , and bearer token . Here is one example of each authentication method: Basic Authentication trigger : type : http httpRequest : url : http://my-api.com method : GET authentication : type : basic basic : user : my-username password : mypassword API Key Authentication trigger : type : http httpRequest : url : http://my-api.com method : GET authentication : type : apiKey apiKey : key : X-Key value : my-key in : header # Either \"header\" or \"query\" Bearer Token Authentication trigger : type : http httpRequest : url : http://my-api.com method : GET authentication : type : bearer bearer : token : my-token","title":"Authentication"},{"location":"test-definition-file/#body","text":"Currently, Testkube supports raw body types that enable you to send text formats over HTTP, for example: JSON. trigger : type : http httpRequest : url : http://my-api.com method : POST body : '{\"name\": \"my Json Object\"}'","title":"Body"},{"location":"test-definition-file/#generator-functions","text":"Sometimes we want to randomize our test data. Maybe we want to try new values or maybe we know our API will fail if the same id is provided more than once. For this use case, you can define generator functions in the test trigger. To use a generator function, wrap it in double curly brackets: {{ uuid() }} . Available functions: Function Description uuid() Generates a random v4 uuid. firstName() Generates a random English first name. lastName() Generates a random English last name. fullName() Generates a random English first and last name. email() Generates a random email address. phone() Generates a random phone number. creditCard() Generates a random credit card number (from 12 to 19 digits). creditCardCvv() Generates a random credit card cvv (3 digits). creditCardExpDate() Generates a random credit card expiration date (mm/yy). randomInt(min, max) Generates a random integer contained in the closed interval defined by [ min , max ].","title":"Generator Functions"},{"location":"test-definition-file/#assertions","text":"Assertions are as important as how you trigger your test. Without them, your test is just a fancy way of executing a request using a CLI command. In this section, we will discuss how you can declare your assertions in your definition file. Before we start, there are two concepts that you must understand to write your tests: selectors and assertions. Selectors are queries that are executed against your trace tree and select a set of spans based on some attributes. They are responsible for defining which spans will be tested against your assertions. Assertions are tests against a specific span based on its attributes. A practical example might be useful: Imagine you have to ensure that all your database select statements take less than 500ms . To write a test for that you must: Select all spans in your trace related to select statements . Check if all those spans lasted less than 500ms . For the first task, we use a selector: span[db.statement contains \"SELECT\"] . While the second one is achieved by using an assertion: tracetest.span.duration < 500ms . Note: When asserting time fields, you can use the following time units: ns (nanoseconds), us (microseconds), ms (milliseconds), s (seconds), m (minutes), and h (hours). Instead of defining tracetest.span.duration <= 3600s , you can set it as tracetest.span.duration <= 1h . To write that in your test definition, you can define the following YAML definition: specs : - selector : span[db.statement contains \"SELECT\"] assertions : - tracetest.span.duration < 500ms As you probably noticed in the test definition structure, you can have multiple assertions for the same selector. This is useful to group related validations. For example, ensuring that all your HTTP calls are successful and take less than 1000ms: specs : - selector : span[tracetest.span.type=\"http\"] assertions : - http.status_code >= 200 - http.status_code < 300 - tracetest.span.duration < 1000ms","title":"Assertions"},{"location":"test-definition-file/#referencing-other-fields-from-the-same-span","text":"You also can reference fields from the same span in your assertions. For example, you can define an assertion to ensure the output number is greater than the input number. testDefinition : - selector : span[name = \"my operation\"] assertions : - myapp.output > myapp.input You also can use basic arithmetic expressions in your assertions: assertions : - myapp.output = myapp.input + 1 Note: This does not take into account the order of operators yet. So an expression 1 + 2 * 3 will be resolved as 9 instead of 7 . This will be fixed in future releases. Available operations in an expression are: + , - , * , and / . For more information about selectors or assertions, take a look at the documentation for those topics.","title":"Referencing Other Fields from the Same Span"},{"location":"test-definition-file/#available-operations","text":"Operator Description = Check if two values are equal. != Check if two values have different values. < Check if value from left side is smaller than the one on the right side of the operation. <= Check if value from left side is smaller or equal to the one on the right side of the operation. > Check if value from left side is larger than the one on the right side of the operation. >= Check if value from left side is larger or equal to the one on the right side of the operation. contains Check if value on the right side of the operation is contained inside of the value of the left side of the operation. not-contains Check if value on the right side of the operation is not contained inside of the value of the left side of the operation.","title":"Available Operations"},{"location":"test-results/","text":"Test Results From the All Tests screen, you can access all your existing tests, create new tests and see the results of any test that has been run. CLick on the settings icon to the right of each test. You can delete the test from here: Click on the arrow next to the test name and the list of test runs will appear: Click on a test run and the Trigger Details screen will open. From here, you can change and save the details of the test. On the top right, there is a button to run the test and a settings icon with the following options: JUnit Results - The test results in JUnit format. Test Definition - The test defintion YAML file. Delete - Delete the test. Click on the Trace tab to open the Trace Details screen: Use the icons at the top right to manipulate the graph. The options are: Zoom In Zoom Out Fit View Mini Map Use the toggle button highlighted below to switch to the Timeline View : Click on the Test tab to see the details of Test Specs and Assertions for the test:","title":"Test Results"},{"location":"test-results/#test-results","text":"From the All Tests screen, you can access all your existing tests, create new tests and see the results of any test that has been run. CLick on the settings icon to the right of each test. You can delete the test from here: Click on the arrow next to the test name and the list of test runs will appear: Click on a test run and the Trigger Details screen will open. From here, you can change and save the details of the test. On the top right, there is a button to run the test and a settings icon with the following options: JUnit Results - The test results in JUnit format. Test Definition - The test defintion YAML file. Delete - Delete the test. Click on the Trace tab to open the Trace Details screen: Use the icons at the top right to manipulate the graph. The options are: Zoom In Zoom Out Fit View Mini Map Use the toggle button highlighted below to switch to the Timeline View : Click on the Test tab to see the details of Test Specs and Assertions for the test:","title":"Test Results"},{"location":"versioning/","text":"Versioning As your system evolves, your tests tend to do the same. However, that might be confusing if you don't have a versioning mechanism in place. Imagine that you wrote a new test for the version v0.5.0 of your application. After some months, your application is in version v0.13.7 . Most likely, your tests changed as you moved your application forward. But without versioning, if you revisit that first test you created, it will look like exactly the one you use today instead of the test you originally wrote. That happens because while you have multiple versions of your application, you only keep track of one version of your tests: the current version. So there is no way of going back in time and seeing what a test looked like in the past. But that is not a problem if you use Tracetest. It has versioning built-in! How It Works Once you create a test, it is tagged as the initial version ( v1 ). Every time you change something in your test (edit its identification details, add assertions, change selectors, etc) Tracetest detects those changes and increase the version by 1. If no changes were made, the version is kept untouched. Change Detection These are the fields of a test that are checked to verify if it has changed: name description trigger test definition selectors assertions Problems If you notice you are editing fields and your test version is not changing, let us know by opening a bug report on our Github Repository.","title":"Versioning"},{"location":"versioning/#versioning","text":"As your system evolves, your tests tend to do the same. However, that might be confusing if you don't have a versioning mechanism in place. Imagine that you wrote a new test for the version v0.5.0 of your application. After some months, your application is in version v0.13.7 . Most likely, your tests changed as you moved your application forward. But without versioning, if you revisit that first test you created, it will look like exactly the one you use today instead of the test you originally wrote. That happens because while you have multiple versions of your application, you only keep track of one version of your tests: the current version. So there is no way of going back in time and seeing what a test looked like in the past. But that is not a problem if you use Tracetest. It has versioning built-in!","title":"Versioning"},{"location":"versioning/#how-it-works","text":"Once you create a test, it is tagged as the initial version ( v1 ). Every time you change something in your test (edit its identification details, add assertions, change selectors, etc) Tracetest detects those changes and increase the version by 1. If no changes were made, the version is kept untouched.","title":"How It Works"},{"location":"versioning/#change-detection","text":"These are the fields of a test that are checked to verify if it has changed: name description trigger test definition selectors assertions","title":"Change Detection"},{"location":"versioning/#problems","text":"If you notice you are editing fields and your test version is not changing, let us know by opening a bug report on our Github Repository.","title":"Problems"},{"location":"websocket/","text":"Websocket endpoint Tracetest allow you to subscribe to updates of resources using websockets. There are two endpoints that you can use to manage subscriptions: Endpoint You can open a websocket connection by sending a request the path /ws . Example: ws://localhost:11633/ws . Messages Subscribing to updates Once the connection is open, you can send a message with the format: { \"type\" : \"subscribe\" , \"resource\" : \"test/{testID}/run/{runID}\" } If a problem happens, you will see an error like: { \"type\" : \"error\" , \"message\" : \"details of the error\" } If the operation executes successfully, you will see a response like: { \"type\" : \"success\" , \"resource\" : \"test/{testID}/run/{runID}\" , \"message\" : { \"subscriptionId\" : \"bdbc6cc8-bba6-4208-a8d3-d3c2c5b3e38b\" } } The subscriptionId is an important field because it is required to cancel the subscription. You should store it, otherwise you will keep receiving updates of a resource that you might not want. Cancel a susbcription Once you have a subscription to a resource, you might want to stop receiving events from that resource. So, there is a unsubscribe message that you can send to achieve that. But send this message to the websocket connection: { \"type\" : \"unsubscribe\" , \"resource\" : \"test/{testID}/run/{runID}\" , \"subscriptionId\" : \"id returned in the subscription command\" } You will receive an error message if any required field is not field. But in case of a successful operation, you will receive a message like: { \"type\" : \"success\" , \"message\" : \"ok\" } This message will be sent regardless if the subscription exists or not.","title":"Websocket endpoint"},{"location":"websocket/#websocket-endpoint","text":"Tracetest allow you to subscribe to updates of resources using websockets. There are two endpoints that you can use to manage subscriptions:","title":"Websocket endpoint"},{"location":"websocket/#endpoint","text":"You can open a websocket connection by sending a request the path /ws . Example: ws://localhost:11633/ws .","title":"Endpoint"},{"location":"websocket/#messages","text":"","title":"Messages"},{"location":"websocket/#subscribing-to-updates","text":"Once the connection is open, you can send a message with the format: { \"type\" : \"subscribe\" , \"resource\" : \"test/{testID}/run/{runID}\" } If a problem happens, you will see an error like: { \"type\" : \"error\" , \"message\" : \"details of the error\" } If the operation executes successfully, you will see a response like: { \"type\" : \"success\" , \"resource\" : \"test/{testID}/run/{runID}\" , \"message\" : { \"subscriptionId\" : \"bdbc6cc8-bba6-4208-a8d3-d3c2c5b3e38b\" } } The subscriptionId is an important field because it is required to cancel the subscription. You should store it, otherwise you will keep receiving updates of a resource that you might not want.","title":"Subscribing to updates"},{"location":"websocket/#cancel-a-susbcription","text":"Once you have a subscription to a resource, you might want to stop receiving events from that resource. So, there is a unsubscribe message that you can send to achieve that. But send this message to the websocket connection: { \"type\" : \"unsubscribe\" , \"resource\" : \"test/{testID}/run/{runID}\" , \"subscriptionId\" : \"id returned in the subscription command\" } You will receive an error message if any required field is not field. But in case of a successful operation, you will receive a message like: { \"type\" : \"success\" , \"message\" : \"ok\" } This message will be sent regardless if the subscription exists or not.","title":"Cancel a susbcription"},{"location":"working-with-traces/","text":"Working with Traces All tests will be listed in the dashboard: Select a test to see its trace details: Each run of the test is listed here along with the Execution Time, Status, Total Number of Assertions, Number of Assertions Passed, Number of Assertions Failed and Actions available for the test. Select a run of the test and the Tracetest dashboard will display:","title":"Working with Traces"},{"location":"working-with-traces/#working-with-traces","text":"All tests will be listed in the dashboard: Select a test to see its trace details: Each run of the test is listed here along with the Execution Time, Status, Total Number of Assertions, Number of Assertions Passed, Number of Assertions Failed and Actions available for the test. Select a run of the test and the Tracetest dashboard will display:","title":"Working with Traces"},{"location":"pokeshop/add-pokemon/","text":"Pokeshop - Add Pokemon Endpoint This endpoint showcases the different checkpoints that can be added to an application to include custom instrumentation such as validation of the incoming data before inserting it into the database. Endpoint Specification Route: /pokemon Method: POST Request Body: { \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Trace Details Assertions Here are some key points that are relevant to this query. Validate the Request Body is Valid To demonstrate the custom span capability from OTEL, this trace contains a checkpoint that validates the incoming request body before inserting the data into the database. To add an assertion to this checkpoint simply click the General span and then head into the custom tab where the custom attribute validation.isValid is displayed. Then click the add assertion button to open the form with the prefilled data. You\u2019ll see the check automatically added to the form, where the selectors and checks can be manually updated if necessary. To finalize the assertion creation just click the save button. Validate the Insert Database Statement To add an assertion to validate that the insert statement was executed with the proper information, we can start by selecting the database span and clicking the add assertion button. Then we can add one or multiple checks on the db.statement attribute to validate the different portions of the statement. After clicking save , the new assertion should show up.","title":"Add Pokemon Endpoint"},{"location":"pokeshop/add-pokemon/#pokeshop-add-pokemon-endpoint","text":"This endpoint showcases the different checkpoints that can be added to an application to include custom instrumentation such as validation of the incoming data before inserting it into the database.","title":"Pokeshop - Add Pokemon Endpoint"},{"location":"pokeshop/add-pokemon/#endpoint-specification","text":"Route: /pokemon Method: POST Request Body: { \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true }","title":"Endpoint Specification"},{"location":"pokeshop/add-pokemon/#trace-details","text":"","title":"Trace Details"},{"location":"pokeshop/add-pokemon/#assertions","text":"Here are some key points that are relevant to this query. Validate the Request Body is Valid To demonstrate the custom span capability from OTEL, this trace contains a checkpoint that validates the incoming request body before inserting the data into the database. To add an assertion to this checkpoint simply click the General span and then head into the custom tab where the custom attribute validation.isValid is displayed. Then click the add assertion button to open the form with the prefilled data. You\u2019ll see the check automatically added to the form, where the selectors and checks can be manually updated if necessary. To finalize the assertion creation just click the save button. Validate the Insert Database Statement To add an assertion to validate that the insert statement was executed with the proper information, we can start by selecting the database span and clicking the add assertion button. Then we can add one or multiple checks on the db.statement attribute to validate the different portions of the statement. After clicking save , the new assertion should show up.","title":"Assertions"},{"location":"pokeshop/import-pokemon/","text":"Pokeshop - Import Pokemon Endpoint This endpoint showcases a more complex scenario involving an async process. Usually, when working with microservices, there are use cases where some of the processing needs to happen asynchronously, for example, when triggering a user notification, generating reports, or processing a payment order. With this endpoint, we provide an example of how users can implement trace-based testing for such scenarios. Endpoint Specification Route: /pokemon/import Method: POST Request Body: { \"id\" : 1 } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true } Trace Assertions Here are some key points that are relevant to this query. Validate the Message Is Sent to the Cue To validate what\u2019s being sent from the API to the worker, we can click the custom queue producer span and validate the messaging.payload attribute exists under the custom tab. To add an assertion targeting this attribute, we can select the add assertion icon that shows up while hovering over it. After that, we can tweak the assertion to match the expected value from the attribute. Clicking add should show the newly created assertion. Validate the Message Is Processed by the Worker The next thing would be to add an assertion related to the worker receiving the message and starting to process the job. We can achieve this by validating that the custom checkpoint for the worker exists. In this case, we can click the import pokemon general span, then click on the add assertion button. After this is done, we can proceed to add checks for the service.name and process.command attributes that should match the specific worker metadata. Clicking save should display the newly created assertion Validate the PokeAPI HTTP Data Information After validating that the message has arrived at the worker, we can start adding assertions to the different steps. The first one is requesting the pokemon information from the poke API, here we can add multiple checks in regards to url, routes, response, status, etc. After having selected the worker HTTP span and clicking the add assertion button, we can start modifying the different checks. Clicking save should show the assertion: Validate HTTP Spans Status Code With Tracetest you can also add checks for not only one but multiple spans. In this case, we\u2019ll be adding an assertion that will affect every HTTP span to validate that the http.status_code is equal 200 . To start this process, click on any of the HTTP spans and then the add assertion button. Then remove the different selector entries from the first input until the only remaining one is the tracetest.span.type . The last step is to add our check using the http.status_code and match it against the 200 value. You\u2019ll see the 2 affected spans message at the top right of the form. By clicking save , it will be shown in the main assertions area. Validate the Insert Database Statement Last but not least, we can add a validation to check if the record was saved to the database by selecting the custom Postgres span and clicking add an assertion . Then we can add checks for both the db.operation to match create and the result to match the JSON expected object. Clicking save will display the new assertion.","title":"Import Pokemon Endpoint"},{"location":"pokeshop/import-pokemon/#pokeshop-import-pokemon-endpoint","text":"This endpoint showcases a more complex scenario involving an async process. Usually, when working with microservices, there are use cases where some of the processing needs to happen asynchronously, for example, when triggering a user notification, generating reports, or processing a payment order. With this endpoint, we provide an example of how users can implement trace-based testing for such scenarios.","title":"Pokeshop - Import Pokemon Endpoint"},{"location":"pokeshop/import-pokemon/#endpoint-specification","text":"Route: /pokemon/import Method: POST Request Body: { \"id\" : 1 } Response: { \"id\" : 1000 , \"name\" : \"meowth\" , \"type\" : \"normal\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/052.png\" , \"isFeatured\" : true }","title":"Endpoint Specification"},{"location":"pokeshop/import-pokemon/#trace","text":"","title":"Trace"},{"location":"pokeshop/import-pokemon/#assertions","text":"Here are some key points that are relevant to this query. Validate the Message Is Sent to the Cue To validate what\u2019s being sent from the API to the worker, we can click the custom queue producer span and validate the messaging.payload attribute exists under the custom tab. To add an assertion targeting this attribute, we can select the add assertion icon that shows up while hovering over it. After that, we can tweak the assertion to match the expected value from the attribute. Clicking add should show the newly created assertion. Validate the Message Is Processed by the Worker The next thing would be to add an assertion related to the worker receiving the message and starting to process the job. We can achieve this by validating that the custom checkpoint for the worker exists. In this case, we can click the import pokemon general span, then click on the add assertion button. After this is done, we can proceed to add checks for the service.name and process.command attributes that should match the specific worker metadata. Clicking save should display the newly created assertion Validate the PokeAPI HTTP Data Information After validating that the message has arrived at the worker, we can start adding assertions to the different steps. The first one is requesting the pokemon information from the poke API, here we can add multiple checks in regards to url, routes, response, status, etc. After having selected the worker HTTP span and clicking the add assertion button, we can start modifying the different checks. Clicking save should show the assertion: Validate HTTP Spans Status Code With Tracetest you can also add checks for not only one but multiple spans. In this case, we\u2019ll be adding an assertion that will affect every HTTP span to validate that the http.status_code is equal 200 . To start this process, click on any of the HTTP spans and then the add assertion button. Then remove the different selector entries from the first input until the only remaining one is the tracetest.span.type . The last step is to add our check using the http.status_code and match it against the 200 value. You\u2019ll see the 2 affected spans message at the top right of the form. By clicking save , it will be shown in the main assertions area. Validate the Insert Database Statement Last but not least, we can add a validation to check if the record was saved to the database by selecting the custom Postgres span and clicking add an assertion . Then we can add checks for both the db.operation to match create and the result to match the JSON expected object. Clicking save will display the new assertion.","title":"Assertions"},{"location":"pokeshop/list-pokemon/","text":"Pokeshop - List Pokemon Endpoint This endpoint returns the list of Pokemon directly from the database (Postgres) based on the provided query. The idea of this query is to showcase a straightforward scenario, where the API layer receives a request from the outside and needs to trigger a database query to get some data and return it to the client. Endpoint Specification Route: /pokemon?take=20&skip=0 Method: GET Response: [ { \"id\" : 25 , \"name\" : \"pikachu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png\" , \"isFeatured\" : true }, { \"id\" : 26 , \"name\" : \"raichu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/026.png\" , \"isFeatured\" : true } ] Trace Assertions Here are some key points that are relevant for this query. Validating the Database Query Speed To add a validation based on a span duration, we can click the specific database span we want to add the test to. After clicking the add assertion button which will display the form, based on the predefined selector, we can start adding the assertions at the bottom. Tracetest adds a custom attribute to all spans called tracetest.span.duration which contains the duration in milliseconds. By selecting that attribute, we can now add the operator and value we want to use. In this case, we are checking that the duration is less than 5 milliseconds. The next step is selecting add and then the assertion should show up in the bottom section as draft mode. Validate the Resulting Body To validate the resulting body we can use one of the attributes coming from the inbound HTTP request called http.response.body . A different way to open the assertion form with prefilled data is by clicking the add assertion plus sign from the span detail attribute section. This way the assertion form will have the selected attribute added as a check from the start. We can compare it directly by using equals or using contains to match a substring. After selecting add , it should show as part of the assertions in edit mode. Validate the Database Statement to Include the Query Parameters To achieve this, we can add an assertion targeting the select query span to contain the limit and offset parameters. To do that we need to select the specific span and click add assertion . Then, we can add a check for the db.statement to contain LIMIT 20 OFFSET 0 like: And by selecting add , it should show up like this:","title":"List Pokemon Endpoints"},{"location":"pokeshop/list-pokemon/#pokeshop-list-pokemon-endpoint","text":"This endpoint returns the list of Pokemon directly from the database (Postgres) based on the provided query. The idea of this query is to showcase a straightforward scenario, where the API layer receives a request from the outside and needs to trigger a database query to get some data and return it to the client.","title":"Pokeshop - List Pokemon Endpoint"},{"location":"pokeshop/list-pokemon/#endpoint-specification","text":"Route: /pokemon?take=20&skip=0 Method: GET Response: [ { \"id\" : 25 , \"name\" : \"pikachu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png\" , \"isFeatured\" : true }, { \"id\" : 26 , \"name\" : \"raichu\" , \"type\" : \"electric\" , \"imageUrl\" : \"https://assets.pokemon.com/assets/cms2/img/pokedex/full/026.png\" , \"isFeatured\" : true } ]","title":"Endpoint Specification"},{"location":"pokeshop/list-pokemon/#trace","text":"","title":"Trace"},{"location":"pokeshop/list-pokemon/#assertions","text":"Here are some key points that are relevant for this query. Validating the Database Query Speed To add a validation based on a span duration, we can click the specific database span we want to add the test to. After clicking the add assertion button which will display the form, based on the predefined selector, we can start adding the assertions at the bottom. Tracetest adds a custom attribute to all spans called tracetest.span.duration which contains the duration in milliseconds. By selecting that attribute, we can now add the operator and value we want to use. In this case, we are checking that the duration is less than 5 milliseconds. The next step is selecting add and then the assertion should show up in the bottom section as draft mode. Validate the Resulting Body To validate the resulting body we can use one of the attributes coming from the inbound HTTP request called http.response.body . A different way to open the assertion form with prefilled data is by clicking the add assertion plus sign from the span detail attribute section. This way the assertion form will have the selected attribute added as a check from the start. We can compare it directly by using equals or using contains to match a substring. After selecting add , it should show as part of the assertions in edit mode. Validate the Database Statement to Include the Query Parameters To achieve this, we can add an assertion targeting the select query span to contain the limit and offset parameters. To do that we need to select the specific span and click add assertion . Then, we can add a check for the db.statement to contain LIMIT 20 OFFSET 0 like: And by selecting add , it should show up like this:","title":"Assertions"}]}